# Lab8

> 计64 翁家翌 2016011446

## 练习1

大致分为如下四种情况：

1. 开始和结束位置在同一块内
2. 开始和结束位置不在同一块内，开始位置未对齐
3. 开始和结束位置不在同一块内，中间对齐的块
4. 开始和结束位置不在同一块内，结束位置未对齐

对于非对齐块的操作，调用 `sfs_bmap_load_noblock` 得到块号之后，可以使用 `sfs_buf_op` 完成非对齐操作

对于对齐块的操作，得到块号之后，使用 `sfs_block_op` 进行整块操作

> 给出设计实现”UNIX的PIPE机制“的概要设方案

#### 管道数据结构

管道本质上就是一个操作系统内核管理的环形缓冲区，所以需要一块内存作为缓冲区，然后需要记录环形缓冲区的头部和尾部。当一个进程尝试从空管道读取数据或者向满管道写入数据的时候，操作系统内核需要将进程阻塞，所以还需要一个读取等待队列和一个写入等待队列。 缓冲区大小通常设为一页的大小4KB。

```c
struct pipe {
    size_t head; // 缓冲区头部
    size_t tail; // 缓冲区尾部
    wait_queue_t read_queue; // 管道读取等待队列
    wait_queue_t write_queue; // 管道写入等待队列
    char * buffer; // 环形缓冲区
};
```

#### inode

添加管道信息数据结构和管道类型号。 

#### 管道操作

##### 创建

首先需要创建管道的信息节点 ，而进程需要得到管道的文件描述符用于读写，所以管道创建接口在创建好信息节点之后，还需要创建两个文件描述符，一个文件描述符只读，另外一个文件描述符只写。 

由于管道只被文件描述符引用，不存在于实际的文件系统中，因此打开计数值永远等于引用计数值。

##### 关闭

当管道信息节点的打开计数变为0后，管道关闭操作就会被虚拟文件系统调用。对于管道而言，引用计数值等于打开计数值。当管道相关的文件描述符全部关闭后，由回收操作进行内存资源回收，关闭操作不需要做任何工作。 

##### 回收

当管道的全部文件描述符关闭后，虚拟文件系统调用管道回收操作回收缓冲区内存以及信息节点使用的内存。 

##### 读取

读取过程采用逐字节读取的方式读取数据，对于每一个字节的数据：

1. 如果缓冲区非空，那么取出一个字节后，唤醒处于写入等待队列中的进程，然后尝试下一个字节；
2. 如果缓冲区为空， 那么进程将自己加入读取等待队列，主动进入阻塞状态，等待进程被唤醒后再次尝试；
3. 如果全部要求的数据全部读取完毕，那么结束读取过程，返回读取到的字节数。

##### 写入

写入过程和读取过程非常类似，采用逐字节读取的方式写入数据，对于每一个字节的数据：

1. 如果缓冲区非满，那么写入一个字节后，唤醒处于读取等待队列中的进程，然后尝试下一个字节；
2. 如果缓冲区为满， 那么进程将自己加入写入等待队列，主动进入阻塞状态，等待进程被唤醒后再次尝试；
3. 如果全部要求的数据全部写入完毕，那么结束读取过程，返回写入的字节数。

## 练习2

`load_icode` 大部分照搬之前lab7的代码，有两处明显的修改

1. 把原来从 `binary` 读出ELF改为从文件里面读取ELF `load_icode_read`，共两处地方

2. 在用户态栈上构建命令行参数。首先设置默认的选择子和寄存器和之前一致，然后我模拟了整个参数压栈过程，具体如下：

   ```c
   struct trapframe *tf = current->tf;
   memset(tf, 0, sizeof(struct trapframe));
   // set default parameter as before
   tf->tf_cs = USER_CS;
   tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
   tf->tf_esp = USTACKTOP;
   tf->tf_eip = elf.e_entry;
   tf->tf_eflags = FL_IF;
   // push raw data into stack
   char* uargv[EXEC_MAX_ARG_NUM];
   uargv[argc] = NULL;
   for (int i = argc - 1; i >= 0; --i) {
       tf->tf_esp -= strlen(kargv[i]) + 1; // add '\0'
       uargv[i] = (char*) tf->tf_esp;
       strcpy(uargv[i], kargv[i]);
   }
   // push char* pointer into stack
   tf->tf_esp = ROUNDDOWN(tf->tf_esp, sizeof(uintptr_t)) - sizeof(char*) * (argc + 1);
   memcpy((char**)tf->tf_esp, uargv, sizeof(char*) * (argc + 1));
   // push argc
   tf->tf_esp -= sizeof(uintptr_t);
   *(uintptr_t*)tf->tf_esp = argc;
   ```

   其中参数内容长度不确定，需要挨个求一下；二维数组压栈的时候，最后一个指针后面应该是一个空指针，表示结束；并且指针存放的时候需要四字节对齐。

> 给出设计实现基于”UNIX的硬链接和软链接机制“的概要设方案

#### 硬链接机制

创建：

1. 将目录项的名字设定为传入参数，目录项的inode号设置为目标文件的inode号。
2. 目标inode的引用计数增加。

删除：

1. 减少目标inode的引用计数。若减为0，清除目标inode及其数据块。

#### 软链接机制

创建：将inode的类型设置为符号链接，文件内容（数据）设置为目标路径字符串。

删除：不需要额外的操作。

## 总结

#### 本实验中重要的知识点，以及与对应的OS原理中的知识点

1. 管道
2. 虚拟文件系统框架
3. 文件描述符
4. 目录
5. inode、打开的文件等结构体
6. inode缓存
7. 简单文件系统
8. ucore特定的文件系统架构

#### 本实验中没有对应的

1. 其他进程间通信机制，例如信号、消息队列和共享内存
2. RAID
3. 磁盘调度算法
4. 磁盘缓存
5. IO